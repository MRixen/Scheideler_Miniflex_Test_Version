MODULE PvMcSys(SYSMODULE)

  !***************************************************
  !Programtype:  Foreground
  !Description:  This is one of the main system module for picking with
  !              PickVision with one or multiple cameras in concurrent operation.
  !              User is adviced not to make any changes to this
  !              file.
  !
  !
  !              Svensk Industriautomation AB.
  !
  ! Copyright (c) Svensk Industriautomation AB 2011
  ! All rights reserved
  !
  !---------------------------------------------------
  !Version           Date            Description
  !---------------------------------------------------
  !4.0              20111124         Created
  !4.1              20120418         Added variable reset in all send procedured, added warning and information /magr
  !                                  Added file write support through PickVision /magr
  !
  !***************************************************
 
  !
  ! definition for belt actions, when to move them
  ! select from Belt Action constant values
  ! Definition, wann das Theaterband anlaufen soll
  ! Auswahl aus Theaterband Aktions-Konstanten
  PERS num BELT_ACTION{4};
  PERS bool ALLOW_AUTO_GRAB{4};
  PERS num nImageGrabDelay{4};
  !
  ! defines which cameras are accepted in CoordTrap
  ! to be used if a second robot accepts its coordinates
  ! in another task with its own CoordTrap
  PERS num START_ACCEPT_CAM:=1;
  PERS num STOP_ACCEPT_CAM:=4;
  PERS bool IS_SLAVE_PVMCSYS:=FALSE;
  !
  ! Belt Action constant values
  ! Theaterband Aktions-Konstanten
  CONST num RUN_NEVER:=0;
  CONST num RUN_NO_DETAIL:=1;
  CONST num RUN_ONE_DETAIL:=2;
  CONST num RUN_ALWAYS:=4;
  !
  ! PickVision status constant values
  ! PickVision Status Konstanten
  CONST num PV_IDLE:=1;
  CONST num PV_OPERATION:=2;
  CONST num PV_STARTING:=4;
  CONST num PV_STOPPING:=8;
  !
  ! camera constant values
  ! Kamera-Konstanten
  CONST num CAMERA_NO_1:=1;
  CONST num CAMERA_NO_2:=2;
  CONST num CAMERA_NO_3:=3;
  CONST num CAMERA_NO_4:=4;
  !
  ! messagebox constant values
  ! messagebox-Konstanten
  CONST num MESSAGE_OK:=1;
  CONST num MESSAGE_YES_NO:=2;
  CONST num RESPONSE_FAIL:=-1;
  CONST num RESPONSE_OK:=1;
  CONST num RESPONSE_YES:=2;
  CONST num RESPONSE_NO:=3;
  !
  ! temporary communication variables PickVision
  ! temporäre Kommunikationsvariablen für PickVision
  PERS num x:=0;
  PERS num y:=0;
  PERS num z:=0;
  PERS num pz:=0;
  PERS num rotX:=0;
  PERS num rotY:=0;
  PERS num rotZ:=0;
  PERS num amountOfDetails:=0;
  PERS num amountOfDetails1:=0;
  PERS num amountOfDetails2:=0;
  PERS num amountOfDetails3:=0;
  PERS num position:=0;
  PERS num action:=1;
  PERS num nPVStatus:=-1;
  PERS string sFreeParameter:="";
  PERS string sMsgResponse:="";
  PERS string sMsgAnswer:="";
  PERS num cam:=1;
  !
  ! PickVision action constant values
  ! PickVision Aktions-Konstanten
  CONST num NO_DETAILS:=1;
  CONST num ONE_DETAIL:=2;
  CONST num MANY_DETAILS:=4;
  CONST num CHANGE_BIN:=8;
  CONST num PICK_INTERLAYER:=16;
  CONST num PICK_INTERLAYER_AND_CHANGE_BIN:=32;
  CONST num MANY_DETAILS_NO_GRAB:=256;
  !
  ! command data to PickVision
  ! Kommando-Daten zu PickVision
  PERS bool bGrab1:=FALSE;
  PERS bool bGrab2:=FALSE;
  PERS bool bGrab3:=FALSE;
  PERS bool bGrab4:=FALSE;
  PERS bool bGrab1DisableMotion:=FALSE;
  PERS bool bGrab2DisableMotion:=FALSE;
  PERS bool bGrab3DisableMotion:=FALSE;
  PERS bool bGrab4DisableMotion:=FALSE;
  PERS bool bCoord:=FALSE;
  PERS bool bClearSend:=FALSE;
  PERS bool bStop:=FALSE;
  PERS bool bPVStatus:=FALSE;
  PERS bool bConfPickCam1:=FALSE;
  PERS bool bConfPickCam2:=FALSE;
  PERS bool bConfPickCam3:=FALSE;
  PERS bool bConfPickCam4:=FALSE;
  PERS bool bConfIntPickCam1:=FALSE;
  PERS bool bConfIntPickCam2:=FALSE;
  PERS bool bConfIntPickCam3:=FALSE;
  PERS bool bConfIntPickCam4:=FALSE;
  PERS bool bFreeParam1Cam1:=TRUE;
  PERS bool bFreeParam1Cam2:=FALSE;
  PERS bool bFreeParam1Cam3:=FALSE;
  PERS bool bFreeParam1Cam4:=FALSE;
  PERS bool bFreeParam2Cam1:=FALSE;
  PERS bool bFreeParam2Cam2:=FALSE;
  PERS bool bFreeParam2Cam3:=FALSE;
  PERS bool bFreeParam2Cam4:=FALSE;
  PERS num nDisablePosCam1:=0;
  PERS num nDisablePosCam2:=0;
  PERS num nDisablePosCam3:=0;
  PERS num nDisablePosCam4:=0;
  PERS num nEnablePosCam1:=0;
  PERS num nEnablePosCam2:=0;
  PERS num nEnablePosCam3:=0;
  PERS num nEnablePosCam4:=0;
  PERS string log:="";
  PERS string sMessageBoxOk:="";
  PERS string sMessageBoxYesNo:="";
  PERS string sInputBox:="";
  PERS string sBlackRegion:="";
  PERS num nContrastCam1:=0;
  PERS num nContrastCam2:=0;
  PERS num nContrastCam3:=0;
  PERS num nContrastCam4:=0;
  PERS num nEdgeHeightCam1:=0;
  PERS num nEdgeHeightCam2:=0;
  PERS num nEdgeHeightCam3:=0;
  PERS num nEdgeHeightCam4:=0;
  PERS num nExposureTimeCam1:=0;
  PERS num nExposureTimeCam2:=0;
  PERS num nExposureTimeCam3:=0;
  PERS num nExposureTimeCam4:=0;
  PERS num nGainCam1:=0;
  PERS num nGainCam2:=0;
  PERS num nGainCam3:=0;
  PERS num nGainCam4:=0;
  PERS num nCurrBinLayer:=0;
  PERS num nCurrLayerDet:=0;
  PERS string sInfoBoxShow:="";
  PERS string sInfoBoxHide:="";
  PERS string sSetAlarm:="";
  PERS string sResetAlarm:="";
  PERS string sSetWarning:="";
  PERS string sResetWarning:="";
  PERS string sSetInformation:="";
  PERS string sResetInformation:="";
  PERS string sFilePathAndName:="";
  PERS string sFileContent:="";
  PERS string sGroupName:="";
  PERS string sDetailName:="";
  PERS num nCameraOnTheFlyDetailSelect:=0;
  PERS bool bCoordReceived{4};
!
  ! MultiCoordinate data received from PickVision
  ! MultiCoordinate Daten von PickVision
  CONST num MAX_NO_COORDS:=20;
  CONST num IS_FREE:=0;
  CONST num IN_USE:=1;
  CONST num MC_In_USE:=1;
  CONST num MC_X:=2;
  CONST num MC_Y:=3;
  CONST num MC_Z:=4;
  CONST num MC_ROTX:=5;
  CONST num MC_ROTY:=6;
  CONST num MC_ROTZ:=7;
  CONST num MC_POSZ:=8;
  CONST num MC_POSITION:=9;
  CONST num MC_AMOUNT_DETAIL:=10;
  CONST num DESIRED_POSITION_1:=1;
  CONST num DESIRED_POSITION_2:=2;
  CONST num DESIRED_POSITION_3:=3;
  CONST num DESIRED_POSITION_4:=4;
  PERS num nCoordIndex{4};
  PERS num nNumberOfCoords{4};
  PERS num nCoordValues{MAX_NO_COORDS,10,4};
  PERS num nMultiCoordinateLastAction{4};
  PERS num nAction{4};
  PERS num nPosition;
  PERS num nPZ;
  PERS num nRotX;
  PERS num nRotY;
  PERS num nRotZ;
  TASK PERS robtarget pPick:=[[174.145,129.671,20.5],[0,0.99992,0.00122,-0.01286],[0,0,0,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];

  !
  ! internal variables multicam
  ! Interne Variablen Multi-Cam
  PERS bool bGrabInProgres{4};
  PERS num nCamera;
  PERS num nLastCamera;
  PERS bool bIsMultiCam:=FALSE;
  PERS bool bStartUp_ShutDown:=FALSE;
  PERS bool bIsMultiTaskSystem;
  PERS bool bPvComReady:=TRUE;
  !
  ! module information from PickVision
  PERS string sModuleCam1:="PickVision/PvMain/ModCam1.MOD";
  PERS string sModuleCam2:="";
  PERS string sModuleCam3:="";
  PERS string sModuleCam4:="";

  !-----------------------------------------------------------------------------
  ! This function sets the camera contrast manually for the current camera
  ! Value shall be from 0 to 100%.
  ! Be aware that this setting overrides PickVisions setting until the detail is started again
  !-----------------------------------------------------------------------------
  PROC CameraContrast(
    num cameraNo, num newValue)

      TEST cameraNo
        CASE CAMERA_NO_1:
          nContrastCam1:=newValue;
          WaitUntil nContrastCam1=0;
        CASE CAMERA_NO_2:
          nContrastCam2:=newValue;
          WaitUntil nContrastCam2=0;
        CASE CAMERA_NO_3:
          nContrastCam3:=newValue;
          WaitUntil nContrastCam3=0;
        CASE CAMERA_NO_4:
          nContrastCam4:=newValue;
          WaitUntil nContrastCam4=0;
      ENDTEST
  ENDPROC

  !-----------------------------------------------------------------------------
  ! This function sets the camera exposure time manually for the current camera
  ! Value shall be from 0 to 100%.
  ! Be aware that this setting overrides PickVisions setting until the detail is started again
  !-----------------------------------------------------------------------------
  PROC CameraExposureTime(
    num cameraNo, num newValue)

      TEST cameraNo
        CASE CAMERA_NO_1:
          nExposureTimeCam1:=newValue;
          WaitUntil nExposureTimeCam1=0;
        CASE CAMERA_NO_2:
          nExposureTimeCam2:=newValue;
          WaitUntil nExposureTimeCam2=0;
        CASE CAMERA_NO_3:
          nExposureTimeCam3:=newValue;
          WaitUntil nExposureTimeCam3=0;
        CASE CAMERA_NO_4:
          nExposureTimeCam4:=newValue;
          WaitUntil nExposureTimeCam4=0;
      ENDTEST
  ENDPROC


  !-----------------------------------------------------------------------------
  ! This function sets the camera gain manually for the current camera
  ! Value shall be from 0 to 100%.
  ! Be aware that this setting overrides PickVisions setting until the detail is started again
  !-----------------------------------------------------------------------------
  PROC CameraGain(
    num cameraNo, num newValue)

      TEST cameraNo
        CASE CAMERA_NO_1:
          nGainCam1:=newValue;
          WaitUntil nGainCam1=0;
        CASE CAMERA_NO_2:
          nGainCam2:=newValue;
          WaitUntil nGainCam2=0;
        CASE CAMERA_NO_3:
          nGainCam3:=newValue;
          WaitUntil nGainCam3=0;
        CASE CAMERA_NO_4:
          nGainCam4:=newValue;
          WaitUntil nGainCam4=0;
      ENDTEST
  ENDPROC

  !-----------------------------------------------------------------------------
  ! This procedure checks the status of the belt, and pulses the belt
  ! again if no inposition signal is present.
  ! Diese Prozedur kontrolliert den Zusad des Theaterbandes nach einem Timeout
  ! und startet das Band wieder, falls kein InPosition Signal ansteht.
  !-----------------------------------------------------------------------------
  LOCAL PROC CheckTimeout(
    VAR signaldo inPositionSignal,
    VAR signaldo runBeltSignal,
    num timeOutCamera)

    VAR bool bSendGrab;

    bSendGrab:=FALSE;
    IF DOutput(inPositionSignal)=0 THEN
      IF (BELT_ACTION{timeOutCamera}<>RUN_NEVER) THEN
        ! we have to shut down the interrupt, else we can get collisions
        ISleep iBeltReady{timeOutCamera};
        Set runBeltSignal;
        WaitTime 0.2;
        Reset runBeltSignal;
        ! maybe we already got the inPositionSignal during the 0.2s.
        IF (DOutput(inPositionSignal) = 1) THEN
          bSendGrab:=TRUE;
        ENDIF
        IWatch iBeltReady{timeOutCamera};
      ENDIF
    ENDIF
     IF bSendGrab=TRUE THEN
       SendGrab timeOutCamera;
    ENDIF
  ENDPROC

  !-----------------------------------------------------------------------------
  ! This procedure clears all coordinate data in the array
  ! Diese Prozedur löscht das ganze Koordinaten-Array
  !-----------------------------------------------------------------------------
  LOCAL PROC ClearCoordinates(
    \num clearCamera)

    VAR num startCamera;
    VAR num stopCamera;

    IF Present(clearCamera) = TRUE THEN
      IF clearCamera < CAMERA_NO_1 clearCamera:=CAMERA_NO_1;
      IF clearCamera > CAMERA_NO_4 clearCamera:=CAMERA_NO_4;
      startCamera:=clearCamera;
      stopCamera:=clearCamera;
    ELSE
      startCamera:=CAMERA_NO_1;
      stopCamera:=CAMERA_NO_4;
    ENDIF

    FOR j FROM startCamera TO stopCamera DO
      FOR i FROM 1 TO MAX_NO_COORDS DO
        nCoordValues{i,MC_IN_USE,j}:=IS_FREE;
        nCoordValues{i,MC_X,j}:=0;
        nCoordValues{i,MC_Y,j}:=0;
        nCoordValues{i,MC_Z,j}:=0;
        nCoordValues{i,MC_ROTX,j}:=0;
        nCoordValues{i,MC_ROTY,j}:=0;
        nCoordValues{i,MC_ROTZ,j}:=0;
        nCoordValues{i,MC_POSZ,j}:=0;
        nCoordValues{i,MC_POSITION,j}:=0;
        nCoordValues{i,MC_AMOUNT_DETAIL,j}:=0;
      ENDFOR
      nCoordIndex{j}:=0;
      nNumberOfCoords{j}:=0;
    ENDFOR
  ENDPROC

  !-----------------------------------------------------------------------------
  ! These procedures tells PickVision to grab a new image. However,
  ! if no details are present, it starts the belts instead, and the
  ! new image is taken in BeltReadyTrap
  ! Diese Prozedur lässt PickVision ein neues Bild machen.
  ! Falls jedoch beim vorhergehenden Bild weniger Teile als BELT_ACTION
  ! gefunden wurden wird stattdessen das Theaterband gestartet
  !-----------------------------------------------------------------------------
  PROC ConfirmPick1()
    SendConfirmPickCam1;
    IF (nAction{CAMERA_NO_1}<=BELT_ACTION{CAMERA_NO_1}) AND (BELT_ACTION{CAMERA_NO_1}<>RUN_NEVER) THEN
      StartBelt CAMERA_NO_1;
      bGrabInProgres{CAMERA_NO_1}:=FALSE;
    ELSE
      IF ALLOW_AUTO_GRAB{CAMERA_NO_1}=TRUE AND (nAction{CAMERA_NO_1} <> MANY_DETAILS_NO_GRAB) THEN
        bGrabInProgres{CAMERA_NO_1}:=TRUE;
        SendGrab CAMERA_NO_1;
      ELSE
        bGrabInProgres{CAMERA_NO_1}:=FALSE;
      ENDIF
    ENDIF
  ENDPROC

   PROC ConfirmPick2()
    SendConfirmPickCam2;
    IF (nAction{CAMERA_NO_2}<=BELT_ACTION{CAMERA_NO_2}) AND (BELT_ACTION{CAMERA_NO_2}<>RUN_NEVER) THEN
      StartBelt CAMERA_NO_2;
      bGrabInProgres{CAMERA_NO_2}:=FALSE;
    ELSE
      IF ALLOW_AUTO_GRAB{CAMERA_NO_2}=TRUE AND (nAction{CAMERA_NO_2} <> MANY_DETAILS_NO_GRAB) THEN
        bGrabInProgres{CAMERA_NO_2}:=TRUE;
        SendGrab CAMERA_NO_2;
      ELSE
        bGrabInProgres{CAMERA_NO_2}:=FALSE;
      ENDIF
    ENDIF
  ENDPROC

   PROC ConfirmPick3()
    SendConfirmPickCam3;
    IF (nAction{CAMERA_NO_3}<=BELT_ACTION{CAMERA_NO_3}) AND (BELT_ACTION{CAMERA_NO_3}<>RUN_NEVER) THEN
      StartBelt CAMERA_NO_3;
      bGrabInProgres{CAMERA_NO_3}:=FALSE;
    ELSE
      IF ALLOW_AUTO_GRAB{CAMERA_NO_3}=TRUE AND (nAction{CAMERA_NO_3} <> MANY_DETAILS_NO_GRAB) THEN
        bGrabInProgres{CAMERA_NO_3}:=TRUE;
        SendGrab CAMERA_NO_3;
      ELSE
        bGrabInProgres{CAMERA_NO_3}:=FALSE;
      ENDIF
    ENDIF
  ENDPROC

   PROC ConfirmPick4()
    SendConfirmPickCam4;
    IF (nAction{CAMERA_NO_4}<=BELT_ACTION{CAMERA_NO_4}) AND (BELT_ACTION{CAMERA_NO_4}<>RUN_NEVER) THEN
      StartBelt CAMERA_NO_4;
      bGrabInProgres{CAMERA_NO_4}:=FALSE;
    ELSE
      IF ALLOW_AUTO_GRAB{CAMERA_NO_4}=TRUE AND (nAction{CAMERA_NO_4} <> MANY_DETAILS_NO_GRAB) THEN
        bGrabInProgres{CAMERA_NO_4}:=TRUE;
        SendGrab CAMERA_NO_4;
      ELSE
        bGrabInProgres{CAMERA_NO_4}:=FALSE;
      ENDIF
    ENDIF
  ENDPROC

  !-----------------------------------------------------------------------------
  ! This function disables search for specified position and camera in PickVision.
  ! Sending value 1000 disables all positions.
  !-----------------------------------------------------------------------------
  PROC DisablePosition(
    num cameraNo,
    num posNo)

      TEST cameraNo
        CASE CAMERA_NO_1:
          nDisablePosCam1:=posNo;
          WaitUntil nDisablePosCam1=0;
        CASE CAMERA_NO_2:
          nDisablePosCam2:=posNo;
          WaitUntil nDisablePosCam2=0;
        CASE CAMERA_NO_3:
          nDisablePosCam3:=posNo;
          WaitUntil nDisablePosCam3=0;
        CASE CAMERA_NO_4:
          nDisablePosCam4:=posNo;
          WaitUntil nDisablePosCam4=0;
      ENDTEST
  ENDPROC

  !-----------------------------------------------------------------------------
  ! This functions clears all earlier coordinates, resets communication parameters
  ! and starts belt again.
  ! Diese Funktion löscht alle früheren koordinaten und stellt die Kommunikations-
  ! parameter zurück und startet das Band
  !-----------------------------------------------------------------------------
  PROC DiscardAndStartBelt(
    num grabCamera)

    nAction{grabCamera}:=NO_DETAILS;
    nMultiCoordinateLastAction{grabCamera}:=NO_DETAILS;
    bGrabInProgres{grabCamera}:=FALSE;
    bCoordReceived{grabCamera}:=FALSE;
    ClearCoordinates\clearCamera:=grabCamera;

    IF (nAction{grabCamera}<=BELT_ACTION{grabCamera}) AND (BELT_ACTION{grabCamera}<>RUN_NEVER) THEN
      StartBelt grabCamera;
    ENDIF
  ENDPROC

  !-----------------------------------------------------------------------------
  ! This functions clears all earlier coordinates, resets communication parameters
  ! and takes a new image
  ! Diese Funktion löscht alle früheren koordinaten und resetted die Kommunikations-
  ! parameter und nimmt ein neues Bild
  !-----------------------------------------------------------------------------
  PROC DiscardAndTakeNewImage(
    num grabCamera)

    nAction{grabCamera}:=NO_DETAILS;
    nMultiCoordinateLastAction{grabCamera}:=NO_DETAILS;
    bGrabInProgres{grabCamera}:=FALSE;
    bCoordReceived{grabCamera}:=FALSE;
    ClearCoordinates\clearCamera:=grabCamera;

    SendGrab grabCamera;
  ENDPROC


  !-----------------------------------------------------------------------------
  ! This function enables search for specified position and camera in PickVision.
  ! Sending value 1000 enbables all positions.
  !-----------------------------------------------------------------------------
  PROC EnablePosition(
    num cameraNo,
    num posNo)

      TEST cameraNo
        CASE CAMERA_NO_1:
          nEnablePosCam1:=posNo;
          WaitUntil nEnablePosCam1=0;
        CASE CAMERA_NO_2:
          nEnablePosCam2:=posNo;
          WaitUntil nEnablePosCam2=0;
        CASE CAMERA_NO_3:
          nEnablePosCam3:=posNo;
          WaitUntil nEnablePosCam3=0;
        CASE CAMERA_NO_4:
          nEnablePosCam4:=posNo;
          WaitUntil nEnablePosCam4=0;
      ENDTEST
  ENDPROC

   !-----------------------------------------------------------------------------
  ! This procedure enforces that a given feeder is in the InPosition state
  ! Diese Prozedure stellt sicher, das der Zuführer ein InPosition-Signal bereithält
  !-----------------------------------------------------------------------------
  !-----------------------------------------------------------------------------
  ! This procedure enforces that a given feeder is in the InPosition state
  ! Diese Prozedure stellt sicher, das der Zuführer ein InPosition-Signal bereithält
  !-----------------------------------------------------------------------------
  LOCAL PROC ForceInPosition(
    num nCameraNo,
    bool doGrab)

    VAR bool bTimeFlag;

    IF (BELT_ACTION{nCameraNo}>RUN_NEVER) THEN
WaitAgain:
      TEST nCameraNo
        CASE CAMERA_NO_1:
          WaitDO DOF_InPosition1,1\MaxTime:=10\TimeFlag:=bTimeFlag;
          IF (bTimeFlag=TRUE) THEN
            PulseDO DOF_RunFeeder1;
            GOTO WaitAgain;
          ENDIF
        CASE CAMERA_NO_2:
          WaitDO DOF_InPosition2,1\MaxTime:=10\TimeFlag:=bTimeFlag;
          IF (bTimeFlag=TRUE) THEN
            PulseDO DOF_RunFeeder2;
            GOTO WaitAgain;
          ENDIF
        CASE CAMERA_NO_3:
          WaitDO DOF_InPosition3,1\MaxTime:=10\TimeFlag:=bTimeFlag;
          IF (bTimeFlag=TRUE) THEN
            PulseDO DOF_RunFeeder3;
            GOTO WaitAgain;
          ENDIF
        CASE CAMERA_NO_4:
          WaitDO DOF_InPosition4,1\MaxTime:=10\TimeFlag:=bTimeFlag;
          IF (bTimeFlag=TRUE) THEN
            PulseDO DOF_RunFeeder4;
            GOTO WaitAgain;
          ENDIF
      ENDTEST
    ENDIF
    IF doGrab THEN
      SendGrab cameraNo;
    ENDIF
  ENDPROC

  !-----------------------------------------------------------------------------
  ! This procedure starts the camera belt if no details are
  ! present and then tells PickVision to grab a new image.
  ! Diese Prozedur startet das kameraband falls keine Teile da sind
  ! und initiert die Aufnahme eines neuen Bildes durch PickVision
  !-----------------------------------------------------------------------------
  PROC GrabImage(
    num grabCamera)

    IF ALLOW_AUTO_GRAB{grabCamera}=TRUE THEN
      WriteLog("PvMcSys::GrabImage Was called with AutoGrab. Not allowed.");
      Stop;
    ENDIF
    WaitUntil bGrabInProgres{grabCamera}=FALSE;
    ! we have to take care of cases where the belt is not moving without InPosition signal
    bGrabInProgres{grabCamera}:=TRUE;
    ! Force belts to be in correct position
    ForceInPosition grabCamera, TRUE;
  ENDPROC

  !-----------------------------------------------------------------------------
  ! This procedure initializes PickVision.
  ! Initialisierung gegenüber PickVision.
  !-----------------------------------------------------------------------------
  PROC InitPickVision()
    VAR num nNumberOfTries;
    !
    ! reset communication variables
    bGrab1:=FALSE;
    bGrab2:=FALSE;
    bGrab3:=FALSE;
    bGrab4:=FALSE;
    bCoord:=FALSE;
    bClearSend:=FALSE;
    bStop:=FALSE;
    bPVStatus:=FALSE;
    bConfPickCam1:=FALSE;
    bConfPickCam2:=FALSE;
    bConfPickCam3:=FALSE;
    bConfPickCam4:=FALSE;
    bConfIntPickCam1:=FALSE;
    bConfIntPickCam2:=FALSE;
    bConfIntPickCam3:=FALSE;
    bConfIntPickCam4:=FALSE;
    bFreeParam1Cam1:=TRUE;
    bFreeParam1Cam2:=FALSE;
    bFreeParam1Cam3:=FALSE;
    bFreeParam1Cam4:=FALSE;
    bFreeParam2Cam1:=FALSE;
    bFreeParam2Cam2:=FALSE;
    bFreeParam2Cam3:=FALSE;
    bFreeParam2Cam4:=FALSE;
    nDisablePosCam1:=0;
    nDisablePosCam2:=0;
    nDisablePosCam3:=0;
    nDisablePosCam4:=0;
    nEnablePosCam1:=0;
    nEnablePosCam2:=0;
    nEnablePosCam3:=0;
    nEnablePosCam4:=0;
    nPVStatus:=-1;
    sFreeParameter:="";
    sMsgResponse:="";
    sMsgAnswer:="";
    log:="";
    !
    ! make PvCom to restart
    bPvComReady:=FALSE;
    WaitUntil bPvComReady=TRUE;
    ! Wait before PickVision is completely initialized
    nNumberOfTries:=1;
    WHILE (SendPVStatus() <> PV_OPERATION) AND (nNumberOfTries <20) DO
      WaitTime 1;
      nNumberOfTries:=nNumberOfTries+1;
    ENDWHILE
    ! clear send queue
    !
    SendClearSend;
    WaitTime 2;
    !
    ! Reset Belt signals
    Reset DOF_RunFeeder1;
    Reset DOF_RunFeeder2;
    Reset DOF_RunFeeder3;
    Reset DOF_RunFeeder4;
    !
    ! call rutine from MainModule, load used cameramodules
    LoadCameraModules;
    !
    ! reset other communication variables
    Reset DOF_Coord;
    Reset DOF_EndCycle;
    Reset DOF_CycleEnded;

    nCamera:=1;
    FOR i FROM CAMERA_NO_1 TO CAMERA_NO_4 DO
      nAction{i}:=NO_DETAILS;
      nMultiCoordinateLastAction{i}:=NO_DETAILS;
      bGrabInProgres{i}:=FALSE;
      bCoordReceived{i}:=FALSE;
    ENDFOR
    ClearCoordinates;
    nPosition:=0;
    nPZ:=0;
    nRotX:=0;
    nRotZ:=0;
    nRotY:=0;
    !
    ! start all belts with allowed automatic start
    FOR i FROM CAMERA_NO_1 TO CAMERA_NO_4 DO
      IF ((ALLOW_AUTO_GRAB{i}=TRUE) AND (BELT_ACTION{i}<>RUN_NEVER)) THEN
        WaitTime 0.5;
        bGrabInProgres{i}:=TRUE;
        SendGrab i;
      ENDIF
    ENDFOR
    bStartUp_ShutDown:=FALSE;
  ENDPROC

  !-----------------------------------------------------------------------------
  ! This functions check wether a certain position is present in the transmitted
  ! coordinates. Can be used to check if any data is present by passing 0 as parameter
  ! Diese Funktion kontroliert ob eine gewünschte Lage vorhanden ist. Kan benutzt
  ! werden um Vorhandensein von Daten zu prüfen (0 als Parameter).
  !-----------------------------------------------------------------------------
  FUNC bool isPositionPresent(
    num cam,
    num desiredPosition)

    !
    ! do not return anything if coordinate transfer isn't finished yet
    IF ((bCoordReceived{cam} = FALSE) OR (nNumberOfCoords{cam}=0))THEN
      RETURN FALSE;
    ENDIF
    !
    ! iterate through all transmitted coordinates
    FOR i FROM 1 TO nNumberOfCoords{cam} DO
      IF ((nCoordValues{i,MC_IN_USE,cam}=IN_USE) AND (nCoordValues{i,MC_POSITION,cam}=desiredPosition OR desiredPosition=0)) THEN
        RETURN TRUE;
      ENDIF
    ENDFOR
    !
    ! we didn't find anything
    RETURN FALSE;
  ENDFUNC

  !-----------------------------------------------------------------------------
  ! This functions count wether a certain position is present in the transmitted
  ! coordinates. Can be used to check if any data is present by passing 0 as parameter
  ! Diese Funktion kontroliert ob eine gewünschte Lage vorhanden ist. Kan benutzt
  ! werden um Vorhandensein von Daten zu prüfen (0 als Parameter).
  !-----------------------------------------------------------------------------
  FUNC num numPositionPresent(
    num cam,
    num desiredPosition)

    !
    VAR num nPositions:=0;
    ! do not return anything if coordinate transfer isn't finished yet
    IF ((bCoordReceived{cam} = FALSE) OR (nNumberOfCoords{cam}=0))THEN
      RETURN 0;
    ENDIF
    !
    ! iterate through all transmitted coordinates
    FOR i FROM 1 TO nNumberOfCoords{cam} DO
      IF ((nCoordValues{i,MC_IN_USE,cam}=IN_USE) AND (nCoordValues{i,MC_POSITION,cam}=desiredPosition OR desiredPosition=0)) THEN
        Incr nPositions;
      ENDIF
    ENDFOR
    !
    RETURN nPositions;
  ENDFUNC

  !-----------------------------------------------------------------------------
  ! This function can be used whenever the user want to write a
  ! MessageBox on the PickVision screen.
  ! PickVision MUST be running.
  ! Diese Funktion kan dazu benutzt werden, um eine Nachricht
  ! auf dem PickVision-Bildschirm anzuzeigen.
  ! PickVision MUSS gestartet sein.
  !-----------------------------------------------------------------------------
  FUNC num PvMessageBox(
    num type,
    string message)

    TEST type
      CASE MESSAGE_OK:
        sMsgResponse:="";
        sMessageBoxOk:="";
        WaitTime 0.001;
        sMessageBoxOk:=message;
        WaitUntil sMessageBoxOk="";
        WaitUntil sMsgResponse="OK";
        sMsgResponse:="";
        RETURN RESPONSE_OK;

      CASE MESSAGE_YES_NO:
        sMsgResponse:="";
        sMessageBoxYesNo:="";
        WaitTime 0.001;
        sMessageBoxYesNo:=message;
        WaitUntil sMessageBoxYesNo="";
        WaitUntil (sMsgResponse="YES") OR (sMsgResponse="NO");
        IF sMsgResponse="YES" THEN
          sMsgResponse:="";
          RETURN RESPONSE_YES;
        ENDIF
        IF sMsgResponse="NO" THEN
          sMsgResponse:="";
          RETURN RESPONSE_NO;
        ENDIF
    ENDTEST

    RETURN RESPONSE_FAIL;
  ENDFUNC

  !-----------------------------------------------------------------------------
  ! This function can be used whenever the user want to write an
  ! InputBox on the PickVision screen and request the operator to enter a value.
  ! PickVision MUST be running.
  ! NOTE: Do not use this function during coordinate transfer, use it during robot progranm startup
  ! Diese Funktion kan dazu benutzt werden, um eine Eingabeanforderung
  ! auf dem PickVision-Bildschirm anzuzeigen.
  ! PickVision MUSS gestartet sein.
  ! ACHTUNG: Diese Funktion nicht während des Koordinatentransfers benutzen, sonder
  ! typischerweise in der StartPhase des Roboterprograms.
  !-----------------------------------------------------------------------------
  FUNC string PvInputBox(
    string message, string suggestData)
    VAR string responseData;

    sMsgAnswer:=suggestData;
    sMsgResponse:="";
    sInputBox:="";
    WaitTime 0.001;
    sInputBox:=message;
    WaitUntil sMsgResponse <> "";
    responseData:=sMsgResponse;
    sMsgResponse:="";

    RETURN responseData;
  ENDFUNC

  !-----------------------------------------------------------------------------
  ! This procedures sets grab region in PickVision
  ! Diese Prozedur setzt das aktive Bildgebiet in PickVision
  ! Application format "A-BBB-CCC-DDD-EEE-F"
  ! A=camera, BBB = startX, CCC=stopX, DDD=startY, EEE=stopY,
  ! F=inside/outside 1=region is black, 0 outside region is black
  ! use "A-000-000-000-000-0" to deactivate function in PickVision
  !-----------------------------------------------------------------------------
  PROC SendBlackRegion(string blackRegion)
    sBlackRegion:="";
    WaitTime 0.001;
    sBlackRegion:=blackRegion;
    WaitUntil sBlackRegion="";
    ! let camera settle
    WaitTime 1;
  ENDPROC

  !-----------------------------------------------------------------------------
  ! These procedures send bGrabX, bCoord, bStop, bClearSend to PickVision
  ! Diese Prozeduren senden bGrabX, bCoord, bStop, bClearSend an PickVision
  !-----------------------------------------------------------------------------
  PROC SendClearSend()
    VAR num nCount;
    VAR bool bTimeFlag;

    IF IS_SLAVE_PVMCSYS=TRUE THEN
      RETURN;
    ENDIF

    nCount:=0;
    WHILE nCount<3 DO
      bClearSend:=FALSE;
      WaitTime 0.001;
      bClearSend:=TRUE;
      WaitUntil bClearSend=FALSE\MaxTime:=3\TimeFlag:=bTimeFlag;
      IF bTimeFlag = TRUE THEN
        bClearSend:=FALSE;
        WaitTime 2;
        nCount:=nCount+1;
      ELSE
        GOTO ContinueWork;
      ENDIF
      IF nCount=3 THEN
        WriteLog("bClearSend not FALSE in routine SendClearSend");
        Stop;
        EXIT;
      ENDIF
    ENDWHILE

ContinueWork:
    WaitTime 2;
    FOR i FROM CAMERA_NO_1 TO CAMERA_NO_4 DO
      bCoordReceived{i}:=FALSE;
    ENDFOR
    RETURN;
  ENDPROC

  PROC SendConfirmInterlayerPickCam1()
    bConfIntPickCam1:=FALSE;
    WaitTime 0.001;
    bConfIntPickCam1:=TRUE;
    WaitUntil bConfIntPickCam1=FALSE;
  ENDPROC

  PROC SendConfirmInterlayerPickCam2()
    bConfIntPickCam2:=FALSE;
    WaitTime 0.001;
    bConfIntPickCam2:=TRUE;
    WaitUntil bConfIntPickCam2=FALSE;
  ENDPROC

  PROC SendConfirmInterlayerPickCam3()
    bConfIntPickCam3:=FALSE;
    WaitTime 0.001;
    bConfIntPickCam3:=TRUE;
    WaitUntil bConfIntPickCam3=FALSE;
  ENDPROC

  PROC SendConfirmInterlayerPickCam4()
    bConfIntPickCam4:=FALSE;
    WaitTime 0.001;
    bConfIntPickCam4:=TRUE;
    WaitUntil bConfIntPickCam4=FALSE;
  ENDPROC

  LOCAL PROC SendConfirmPickCam1()
    bConfPickCam1:=FALSE;
    WaitTime 0.001;
    bConfPickCam1:=TRUE;
    WaitUntil bConfPickCam1=FALSE;
  ENDPROC

  LOCAL PROC SendConfirmPickCam2()
    bConfPickCam2:=FALSE;
    WaitTime 0.001;
    bConfPickCam2:=TRUE;
    WaitUntil bConfPickCam2=FALSE;
  ENDPROC

  LOCAL PROC SendConfirmPickCam3()
    bConfPickCam3:=FALSE;
    WaitTime 0.001;
    bConfPickCam3:=TRUE;
    WaitUntil bConfPickCam3=FALSE;
  ENDPROC

  LOCAL PROC SendConfirmPickCam4()
    bConfPickCam4:=FALSE;
    WaitTime 0.001;
    bConfPickCam4:=TRUE;
    WaitUntil bConfPickCam4=FALSE;
  ENDPROC

  PROC SendEdgeHeight(
    num camera,
    num edgeHeight)

    TEST camera
        CASE CAMERA_NO_1:
          nEdgeHeightCam1:=0;
          WaitTime 0.001;
          nEdgeHeightCam1:= edgeHeight;
          WaitUntil nEdgeHeightCam1=0;
        CASE CAMERA_NO_2:
          nEdgeHeightCam2:=0;
          WaitTime 0.001;
          nEdgeHeightCam2:= edgeHeight;
          WaitUntil nEdgeHeightCam2=0;
        CASE CAMERA_NO_3:
          nEdgeHeightCam3:=0;
          WaitTime 0.001;
          nEdgeHeightCam3:= edgeHeight;
          WaitUntil nEdgeHeightCam3=0;
        CASE CAMERA_NO_4:
          nEdgeHeightCam4:=0;
          WaitTime 0.001;
          nEdgeHeightCam4:= edgeHeight;
          WaitUntil nEdgeHeightCam4=0;
      ENDTEST
  ENDPROC
  FUNC string SendFreeParameter1(
    num camera)
    VAR string sReturnValue;
    VAR bool bTimeFlag;

    sFreeParameter:="";
    TEST camera
      CASE CAMERA_NO_1:
        bFreeParam1Cam1:=FALSE;
        WaitTime 0.001;
        bFreeParam1Cam1:=TRUE;
        WaitUntil bFreeParam1Cam1=FALSE;
      CASE CAMERA_NO_2:
        bFreeParam1Cam2:=FALSE;
        WaitTime 0.001;
        bFreeParam1Cam2:=TRUE;
        WaitUntil bFreeParam1Cam2=FALSE;
      CASE CAMERA_NO_3:
        bFreeParam1Cam3:=FALSE;
        WaitTime 0.001;
        bFreeParam1Cam3:=TRUE;
        WaitUntil bFreeParam1Cam3=FALSE;
      CASE CAMERA_NO_4:
        bFreeParam1Cam4:=FALSE;
        WaitTime 0.001;
        bFreeParam1Cam4:=TRUE;
        WaitUntil bFreeParam1Cam4=FALSE;
    ENDTEST

    WaitUntil sFreeParameter<>""\MaxTime:=2\TimeFlag:=bTimeFlag;
    IF bTimeFlag = TRUE THEN
      RETURN "-1";
    ENDIF
    sReturnValue:=sFreeParameter;
    sFreeParameter:="";

    RETURN sReturnValue;
  ENDFUNC

  FUNC string SendFreeParameter2(
    num camera)
    VAR string sReturnValue;
    VAR bool bTimeFlag;

    sFreeParameter:="";
    TEST camera
      CASE CAMERA_NO_1:
        bFreeParam2Cam1:=FALSE;
        WaitTime 0.001;
        bFreeParam2Cam1:=TRUE;
        WaitUntil bFreeParam2Cam1=FALSE;
      CASE CAMERA_NO_2:
        bFreeParam2Cam2:=FALSE;
        WaitTime 0.001;
        bFreeParam2Cam2:=TRUE;
        WaitUntil bFreeParam2Cam2=FALSE;
      CASE CAMERA_NO_3:
        bFreeParam2Cam3:=FALSE;
        WaitTime 0.001;
        bFreeParam2Cam3:=TRUE;
        WaitUntil bFreeParam2Cam3=FALSE;
      CASE CAMERA_NO_4:
        bFreeParam2Cam4:=FALSE;
        WaitTime 0.001;
        bFreeParam2Cam4:=TRUE;
        WaitUntil bFreeParam2Cam4=FALSE;
    ENDTEST


    WaitUntil sFreeParameter<>""\MaxTime:=2\TimeFlag:=bTimeFlag;
    IF bTimeFlag = TRUE THEN
      RETURN "-1";
    ENDIF
    sReturnValue:=sFreeParameter;
    sFreeParameter:="";

    RETURN sReturnValue;
  ENDFUNC

  PROC SendGrab(num nCameraNo)
      TEST nCameraNo
        CASE CAMERA_NO_1:
          bGrabInProgres{CAMERA_NO_1}:=TRUE;
          bGrab1:=FALSE;
          WaitTime 0.001;
          bGrab1:=TRUE;
          WaitUntil bGrab1=FALSE;
        CASE CAMERA_NO_2:
          bGrabInProgres{CAMERA_NO_2}:=TRUE;
          bGrab2:=FALSE;
          WaitTime 0.001;
          bGrab2:=TRUE;
          WaitUntil bGrab2=FALSE;
        CASE CAMERA_NO_3:
          bGrabInProgres{CAMERA_NO_3}:=TRUE;
          bGrab3:=FALSE;
          WaitTime 0.001;
          bGrab3:=TRUE;
          WaitUntil bGrab3=FALSE;
        CASE CAMERA_NO_4:
          bGrabInProgres{CAMERA_NO_4}:=TRUE;
          bGrab4:=FALSE;
          WaitTime 0.001;
          bGrab4:=TRUE;
          WaitUntil bGrab4=FALSE;
      ENDTEST
  ENDPROC

  FUNC num SendPVStatus()
    VAR num nReturnValue;
    VAR bool bTimeFlag;

    nPVStatus:=-1;
    bPVStatus:=FALSE;
    WaitTime 0.001;
    bPVStatus:=TRUE;
    WaitUntil bPVStatus=FALSE;

    WaitUntil nPVStatus<>-1\MaxTime:=2\TimeFlag:=bTimeFlag;
    IF bTimeFlag = TRUE THEN
      RETURN -1;
    ENDIF
    nReturnValue:=nPVStatus;
    nPVStatus:=-1;

    RETURN nReturnValue;
  ENDFUNC

  LOCAL PROC SendStop()
    bStop:=FALSE;
    WaitTime 0.001;
    bStop:=TRUE;
    WaitUntil bStop=FALSE;
  ENDPROC

  ! Format: messageData = "nnnnnnn:MessageToShow" where nnnnnn is a valid, unique id number
  PROC SetAlarm(string messageData)
    sSetAlarm:="";
    WaitTime 0.001;
    sSetAlarm:=messageData;
    WaitUntil sSetAlarm="";
  ENDPROC

  ! Format: messageData = "nnnnnnn" where nnnnnn is the  valid, unique id number to reset
  PROC ResetAlarm(string messageData)
    sResetAlarm:="";
    WaitTime 0.001;
    sResetAlarm:=messageData;
    WaitUntil sResetAlarm="";
  ENDPROC

  ! Format: messageData = "nnnnnnn:MessageToShow" where nnnnnn is a valid, unique id number
  PROC SetWarning(string messageData)
    sSetWarning:="";
    WaitTime 0.001;
    sSetWarning:=messageData;
    WaitUntil sSetWarning="";
  ENDPROC

  ! Format: messageData = "nnnnnnn" where nnnnnn is the  valid, unique id number to reset
  PROC ResetWarning(string messageData)
    sResetWarning:="";
    WaitTime 0.001;
    sResetWarning:=messageData;
    WaitUntil sResetWarning="";
  ENDPROC

  ! Format: messageData = "nnnnnnn:MessageToShow" where nnnnnn is a valid, unique id number
  PROC SetInformation(string messageData)
    sSetInformation:="";
    WaitTime 0.001;
    sSetInformation:=messageData;
    WaitUntil sSetInformation="";
  ENDPROC
  
  ! Format: messageData = "nnnnnnn" where nnnnnn is the  valid, unique id number to reset
  PROC ResetInformation(string messageData)
    sResetInformation:="";
    WaitTime 0.001;
    sResetInformation:=messageData;
    WaitUntil sResetInformation="";
  ENDPROC

  ! Format: filename example: "c:\\folder1\\folder2\\robotdata.txt"
  ! Format: messagedata example: "line1\\rline2\\rline3"
  PROC WriteFilePickVision(string fileName, string messageData)
    sFileContent:=messageData;
    sFilePathAndName:="";
    WaitTime 0.001;
    sFilePathAndName:=fileName;
    WaitUntil sFilePathAndName="";
  ENDPROC
  
  FUNC bool SelectDetailOnTheFly(num cameraNumber, string groupName, string detailName)
    IF (cameraNumber < CAMERA_NO_1) OR (cameraNumber > CAMERA_NO_4) THEN
      ! wrong range of camera number
      Stop;
      EXIT;
    ENDIF

    sDetailName:="";
    WaitTime 0.001;
    sGroupName:=groupName;
    nCameraOnTheFlyDetailSelect:=cameraNumber;
    sDetailName:=detailName;
    WaitUntil (sDetailName="") OR (sDetailName="FAIL");
    IF (sDetailName = "") THEN
      RETURN TRUE;
    ELSE
      RETURN FALSE;
    ENDIF
  ENDFUNC
  !-----------------------------------------------------------------------------
  ! This procedure waits for new coordinates and then calculates
  ! the gripping position.
  ! Diese Prozedur wartet auf neue Koordinaten und berechnet die
  ! neue Greifposition.
  !-----------------------------------------------------------------------------
  PROC SetNextTarget(
    num setCamera,
    \num desiredPosition)

    VAR bool bTimeFlag;
    VAR num setPosition;
    VAR num useCoordIndex;
    VAR num testCoordIndex;
    VAR bool bTempArray{4};

    !
    ! take the right choice which position to use in setnexttarget
    IF Present(desiredPosition) = FALSE THEN
      setPosition:=0;
    ELSE
      setPosition:=desiredPosition;
    ENDIF

    !
    ! find correct next coordinate in array
    useCoordIndex:=0;
    testCoordIndex:=1;
    WHILE ((testCoordIndex<=nNumberOfCoords{setCamera}) AND (useCoordIndex=0)) DO
      IF ((nCoordValues{testCoordIndex,MC_IN_USE,setCamera}=IN_USE) AND (nCoordValues{testCoordIndex,MC_POSITION,setCamera}=setPosition OR setPosition=0)) THEN
        useCoordIndex:=testCoordIndex;
      ENDIF
      testCoordIndex:=testCoordIndex+1;
    ENDWHILE
    IF (useCoordIndex=0) THEN
      ! shall never happen, user error because isPositionPresent was not used.
      WriteLog("PvMcSys::SetNextTarget useCoordIndex=0 when trying to find position");
      Stop;
    ENDIF
    !
    ! store coordinates for use in Pick
    pPick.trans.x:=nCoordValues{useCoordIndex,MC_X,setCamera};
    pPick.trans.y:=nCoordValues{useCoordIndex,MC_Y,setCamera};
    pPick.trans.z:=nCoordValues{useCoordIndex,MC_Z,setCamera};
    nRotX:=nCoordValues{useCoordIndex,MC_ROTX,setCamera}+180;
    nRotY:=nCoordValues{useCoordIndex,MC_ROTY,setCamera};
    nRotZ:=nCoordValues{useCoordIndex,MC_ROTZ,setCamera}-90;
    pPick.rot:=OrientZYX(nRotZ,nRotY,nRotX);
    nPZ:=nCoordValues{useCoordIndex,MC_POSZ,setCamera};
    nPosition:=nCoordValues{useCoordIndex,MC_POSITION,setCamera};
    ! release coordinate
    nCoordValues{useCoordIndex,MC_IN_USE,setCamera}:=IS_FREE;
    !
    ! check if this was the last coordinate
    IF isPositionPresent(setCamera,0)=FALSE THEN
      nAction{setCamera}:=nMultiCoordinateLastAction{setCamera};
      ClearCoordinates\clearCamera:=setCamera;
      nNumberOfCoords{setCamera}:=0;
      bCoordReceived{setCamera}:=FALSE;
    ELSE
      nAction{setCamera}:=MANY_DETAILS_NO_GRAB;
    ENDIF
    nLastCamera:=setCamera;
  ENDPROC

  !-----------------------------------------------------------------------------
  ! This procedure starts the belt corresponding to
  ! the given inputs and outputs
  ! Diese Prozedure startet das Band entsprechend der
  ! gegebenen Ein- und Ausgänge.
  !-----------------------------------------------------------------------------
  PROC StartBelt(num nCameraNo)
      TEST nCameraNo
        CASE CAMERA_NO_1:
          Set DOF_RunFeeder1;
          WaitTime 0.2;
          Reset DOF_RunFeeder1;
        CASE CAMERA_NO_2:
          Set DOF_RunFeeder2;
          WaitTime 0.2;
          Reset DOF_RunFeeder2;
        CASE CAMERA_NO_3:
          Set DOF_RunFeeder3;
          WaitTime 0.2;
          Reset DOF_RunFeeder3;
        CASE CAMERA_NO_4:
          Set DOF_RunFeeder4;
          WaitTime 0.2;
          Reset DOF_RunFeeder4;
      ENDTEST
  ENDPROC

  !-----------------------------------------------------------------------------
  ! This procedure can be used if the robot program wants to stop PickVision,
  ! for instance when no parts are available.
  ! Diese Prozedure kan benutzt werden falls das Roboterprogram PickVision stoppen
  ! will, z.B. wenn keine neuen Teile mer da sind.
  !-----------------------------------------------------------------------------
  PROC StopPickVision()
    SendStop;
  ENDPROC

  !-----------------------------------------------------------------------------
  ! This procedure can be used whenever the user want to write a
  ! log item in the PickVision log.
  ! Diese Prozedure kan benutzt werden, um einen Eintrag in der
  ! LogDatei von PickVision einzufügen.
  !-----------------------------------------------------------------------------
  PROC WriteLog(
    string logItem)

    log:=logItem;
    WaitUntil log="";
  ENDPROC
ENDMODULE
